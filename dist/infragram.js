(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function urlHash() {

function getUrlHashParameter(param) {

  var params = getUrlHashParameters();
  return params[param];

}

function getUrlHashParameters() {

  var sPageURL = window.location.hash;
  if (sPageURL) sPageURL = sPageURL.split('#')[1];
  var pairs = sPageURL.split('&');
  var object = {};
  pairs.forEach(function(pair, i) {
    pair = pair.split('=');
    if (pair[0] != '') object[pair[0]] = pair[1];
  });
  return object;
}

// accepts an object like { paramName: value, paramName1: value }
// and transforms to: url.com#paramName=value&paramName1=value
function setUrlHashParameters(params) {

  var keys = Object.keys(params);
  var values = Object.values(params);
  var pairs = [];
  keys.forEach(function(key, i) {
    if (key != '') pairs.push(keys[i] + '=' + values[i]);
  });
  var hash = pairs.join('&');
  window.location.hash = hash;

}

function setUrlHashParameter(param, value) {

  var params = getUrlHashParameters();
  params[param] = value;
  setUrlHashParameters(params);

}

return {
  getUrlHashParameter:   getUrlHashParameter,
  getUrlHashParameters:  getUrlHashParameters,
  setUrlHashParameter:   setUrlHashParameter,
  setUrlHashParameters:  setUrlHashParameters
}

}

module.exports = urlHash;

},{}],2:[function(require,module,exports){
Infragram = function Infragram(options) {
  options = options || {};
  options.uploader = options.uploader || false;

  options.processors = {
    'webgl':           require('./processors/webgl'),
    'javascript':      require('./processors/javascript'),
    //'image-sequencer': require('./processors/image-sequencer')
  }

  options.processor = options.processor || 'javascript';
  options.processor = options.processors[options.processor]();

  return {
    Dispatch: require('./dispatch')(options, options.processor),
    Interface: require('./interface')(options),
    processors: options.processors
  }
}
module.exports = Infragram;

},{"./dispatch":3,"./interface":5,"./processors/javascript":6,"./processors/webgl":7}],3:[function(require,module,exports){
// Generated by CoffeeScript 2.1.0
// This file was adapted from infragram-js:
// http://github.com/p-v-o-s/infragram-js.

module.exports = function Dispatch(options, processor) {

  options.colorized      = options.colorized      || false;
  options.mode           = options.mode           || "raw",
  options.video_live     = options.video_live     || false,
  options.webGlSupported = options.webGlSupported || false; // move into processor

  var log = []; // a record of previous commands run

  // this should accept an object with parameters r,g,b,h,s,v,m and mode
  options.run_infragrammar = function run_infragrammar(mode) {
    save_log();
    options.colorized = false;
    return processor.runInfragrammar(mode);
  }

  // this maps -1-1 to 0-1, i guess
  options.run_colorize = function run_colorize() {
    if (processor.colorify) {
      render(processor.colorify(infragrammar_mono(image), function(x) {
        return colormap((x + 1) / 2);
      }));
    }
    return true;
  }

  function downloadImage() {
    var event, format, lnk;
    // create an "off-screen" anchor tag
    lnk = document.createElement("a");
    // the key here is to set the download attribute of the a tag
    lnk.href = options.processor.getCurrentImage();
    if (lnk.href.match('image/jpeg')) {
      format = "jpg";
    } else {
      format = "png";
    }
    lnk.download = (new Date()).toISOString().replace(/:/g, "_") + "." + format;
    // create a "fake" click-event to trigger the download
    if (document.createEvent) {
      event = document.createEvent("MouseEvents");
      event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      lnk.dispatchEvent(event);
    } else if (lnk.fireEvent) {
      lnk.fireEvent("onclick");
    }
    return true;
  }

  // from a local URL (remote may be against js security rules)
  function fetch_image(src, mode) {
    var img;
    $("#save-modal-btn").show();
    $("#save-zone").show();
    img = new Image();
    if (options.uploader) {
      img.onload = function() {
        var filename;
        filename = src.split('/');
        filename = filename[filename.length - 1];
        FileUpload.setFilename(filename);
        if (mode) {
          if (mode.substring(0, 5) === "infra") {
            $("#modeSwitcher").val(mode).change();
          } else {
            $("button#" + mode).button("toggle");
            $("button#" + mode).click(); // this should be via a direct call, not a click; the show.jade page should not require buttons!
          }
        }
        options.save_infragrammar_expressions(params);
        if (mode === "ndvi") {
          options.save_infragrammar_expressions({
            'm': '(R-B)/(R+B)'
          });
          mode = "infragrammar_mono";
        } else if (mode === "nir") {
          options.save_infragrammar_expressions({
            'm': 'R'
          });
          mode = "infragrammar_mono";
        } else if (mode === "raw") {
          options.save_infragrammar_expressions({
            'r': 'R',
            'g': 'G',
            'b': 'B'
          });
          mode = "infragrammar";
        }
        options.processor.updateImage(this);
        if (params['color'] === "true" || params['c'] === "true") {
          options.colorized = true; // before run_infrag, so it gets logged
        }
        run_infragrammar(mode); // this sets colorized to false!
        if (params['color'] === "true" || params['c'] === "true") {
          options.colorized = true; // again, so it gets run 
        }
        if (options.colorized) {
          $("button#color").button("toggle");
          return run_colorize();
        }
      }
    }
    return img.src = src;
  }

  // saving inputs/expressions:

  // can we move this into interface?
  options.save_infragrammar_inputs = function save_infragrammar_inputs() {
    mode = $('#modeSwitcher').val();
    return options.save_infragrammar_expressions({
      'r': $('#r_exp').val(),
      'g': $('#g_exp').val(),
      'b': $('#b_exp').val(),
      'm': $('#m_exp').val(),
      'h': $('#h_exp').val(),
      's': $('#s_exp').val(),
      'v': $('#v_exp').val()
    });
  }

  options.save_infragrammar_expressions = function save_infragrammar_expressions(args) {
    if (mode === "infragrammar") {
      processor.save_expressions(args['r'], args['g'], args['b']);
    } else if (mode === "infragrammar_mono") {
      processor.save_expressions(args['m'], args['m'], args['m']);
    } else if (mode === "infragrammar_hsv") {
      return processor.save_expressions_hsv(args['h'], args['s'], args['v']);
    }
  }

  // Move this all to a log.js file:

  function log_mono() {
    var logEntry;
    logEntry = "mode=infragrammar_mono";
    logEntry += $("#m_exp").val() ? "&m=" + $("#m_exp").val() : "";
    logEntry += options.colorized ? "&c=true" : ""; // no way to succinctly store the colormap... just offer range of colorizations at view-time?
    return log.push(logEntry);
  }

  function log_hsv() {
    var logEntry;
    logEntry = "mode=infragrammar_hsv";
    logEntry += $("#h_exp").val() ? "&h=" + $("#h_exp").val() : "";
    logEntry += $("#s_exp").val() ? "&s=" + $("#s_exp").val() : "";
    logEntry += $("#v_exp").val() ? "&v=" + $("#v_exp").val() : "";
    return log.push(logEntry);
  }

  function log_rgb() {
    var logEntry;
    logEntry = "mode=infragrammar";
    logEntry += $("#r_exp").val() ? "&r=" + $("#r_exp").val() : "";
    logEntry += $("#g_exp").val() ? "&g=" + $("#g_exp").val() : "";
    logEntry += $("#b_exp").val() ? "&b=" + $("#b_exp").val() : "";
    return log.push(logEntry);
  }

  function save_log() {
    if (mode === "infragrammar_mono") {
      return log_mono();
    } else if (mode === "infragrammar_hsv") {
      return log_hsv();
    } else if (mode === "infragrammar") {
      return log_rgb();
    }
  }

  return {
    downloadImage: downloadImage,
    fetch_image: fetch_image,
    log: log,
    log_hsv: log_hsv,
    log_mono: log_mono,
    log_rgb: log_rgb,
    run_colorize: options.run_colorize,
    run_infragrammar: options.run_infragrammar,
    save_infragrammar_expressions: options.save_infragrammar_expressions,
    save_infragrammar_inputs: options.save_infragrammar_inputs,
    save_log: save_log
  }

}

},{}],4:[function(require,module,exports){
// Generated by CoffeeScript 2.1.0
// This file was adapted from infragram-js:
// http://github.com/p-v-o-s/infragram-js.
module.exports = FileUpload = {

  socket: null,
  file: null,
  serverFilename: "",

  isLoadedFromFile: function() {
    if (FileUpload.file) {
      return true;
    } else {
      return false;
    }
  },

  getFilename: function() {
    return FileUpload.serverFilename;
  },

  setFilename: function(name) {
    return FileUpload.serverFilename = name;
  },

  uploadThumbnail: function(src, callback) {
    var img;
    img = new Image();
    img.onload = function() {
      var canvas, ctx, dataUrl;
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");
      canvas.width = 260;
      canvas.height = 195;
      ctx.drawImage(this, 0, 0, this.width, this.height, 0, 0, canvas.width, canvas.height);
      callback = callback.toString();
      dataUrl = canvas.toDataURL("image/jpeg");
      return FileUpload.socket.emit("thumbnail_start", {
        "name": FileUpload.serverFilename,
        "data": dataUrl,
        "callback": callback
      });
    };
    return img.src = src;
  },

  fromFile: function(files, callback, upload) {
    var reader;
    if (files && files[0]) {
      $("#file-sel").prop("disabled", true);
      $("#save-modal-btn").prop("disabled", true);
      FileUpload.file = files[0];
      FileUpload.file.reader = new FileReader();
      if (upload) {
        FileUpload.file.reader.onload = function(event) {
          return FileUpload.socket.emit("image_send", {
            "name": FileUpload.serverFilename,
            "size": FileUpload.file.size,
            "data": event.target.result
          });
        };
        FileUpload.socket.emit("image_send", {
          "name": files[0].name,
          "size": files[0].size
        });
      }
      FileUpload.file.uploaded = 0;
      reader = new FileReader();
      reader.onload = function(event) {
        var img;
        img = new Image();
        img.onload = function() {
          return callback(this);
        };
        return img.src = event.target.result;
      };
      return reader.readAsDataURL(files[0]);
    }
  },

  duplicate: function(callback) {
    callback = callback.toString();
    return FileUpload.socket.emit("duplicate_start", {
      "name": FileUpload.serverFilename,
      "callback": callback
    });
  },

  fromBase64: function(name, data, callback) {
    callback = callback.toString();
    return FileUpload.socket.emit("base64_start", {
      "name": name,
      "data": data,
      "callback": callback
    });
  },

  initialize: function(options) {
    options = options || {};
    options.rememberTransport = options.rememberTransport || false;
    options.transports = options.transports || ['websocket', 'AJAX long-polling'];

    if (options.socket) {
      FileUpload.socket = io.connect(window.location.protocol + "//" + window.location.host, options);
      FileUpload.socket.on("image_request", function(data) {
        var file, newFile, txt;
        file = FileUpload.file;
        txt = $("#save-modal-btn").html().split(/\s-\s/g)[0];
        txt += " - " + Math.round((file.uploaded / file.size) * 100) + "%";
        $("#save-modal-btn").html(txt);
        newFile = file.slice(file.uploaded, file.uploaded + Math.min(data["chunk"], file.size - file.uploaded));
        FileUpload.file.uploaded += data["chunk"];
        FileUpload.serverFilename = data["name"];
        return file.reader.readAsDataURL(newFile);
      });
      FileUpload.socket.on("image_done", function(data) {
        var txt;
        if (data["error"]) {
          alert(data["error"]);
        } else {
          FileUpload.serverFilename = data["name"];
        }
        txt = $("#save-modal-btn").html().split(/\s-\s/g)[0];
        $("#save-modal-btn").html(txt);
        $("#file-sel").prop("disabled", false);
        return $("#save-modal-btn").prop("disabled", false);
      });
      FileUpload.socket.on("base64_done", function(data) {
        FileUpload.serverFilename = data["name"];
        eval("var callback=" + data["callback"]);
        return callback();
      });
      FileUpload.socket.on("duplicate_done", function(data) {
        if (data["error"]) {
          return alert(data["error"]);
        } else {
          FileUpload.serverFilename = data["name"];
          eval("var callback=" + data["callback"]);
          return callback();
        }
      });
      FileUpload.socket.on("thumbnail_done", function(data) {
        eval("var callback=" + data["callback"]);
        return callback();
      });
    }

  }
}

},{}],5:[function(require,module,exports){
module.exports = function Interface(options) {

  var urlHash = require('urlhash')();
  var FileUpload = require('./file-upload');

  $(document).ready(function() {

    if (options.uploadable) FileUpload.initialize({ socket: options.uploadable });

    $("#image-container").ready(function() {
      var enablewebgl, idNameMap, src;
      enablewebgl = urlHash.getUrlHashParameter("webgl") === "true" ? true : false;
      webGlSupported = enablewebgl && glInitInfragram();
      if (webGlSupported) {
        $("#webgl-activate").html("&laquo; Go back to JS version");
      }
      idNameMap = {
        "#m_exp": "m",
        "#r_exp": "r",
        "#g_exp": "g",
        "#b_exp": "b",
        "#h_exp": "h",
        "#s_exp": "s",
        "#v_exp": "v"
      };
      urlHash.setUrlHashParameter(idNameMap);
      src = urlHash.getUrlHashParameter('src');
      if (src) {
        params = parametersObject(location.search.split('?')[1]);
        mode = params['mode'];
        fetch_image(src);
      }
      return true;
    });

    $("#file-sel").change(function() {
      $("#save-modal-btn").show();
      $("#save-zone").show();
      FileUpload.fromFile(this.files, options.processor.updateImage, options.uploadable);
      $('#preset-modal').modal('show');
      return true;
    });

    $("#preset_raw").click(function() {
      $('#modeSwitcher').val("infragrammar").change();
      $('#r_exp').val("R");
      $('#g_exp').val("G");
      $('#b_exp').val("B");
      $('#preset-modal').modal('hide');
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        return glHandleOnClickRaw();
      } else {
        return options.run_infragrammar(mode);
      }
    });

    $("#preset_ndvi_blue").click(function() {
      $('#modeSwitcher').val("infragrammar_mono").change();
      $('#m_exp').val("(R-B)/(R+B)");
      $('#preset-modal').modal('hide');
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        return glHandleOnSubmitInfraMono();
      } else {
        return options.run_infragrammar(mode);
      }
    });

    $("#preset_ndvi_blue_color").click(function() {
      $('#modeSwitcher').val("infragrammar_mono").change();
      $('#m_exp').val("(R-B)/(R+B)");
      $('#preset-modal').modal('hide');
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        glHandleOnClickColor();
        return glHandleOnClickNdvi();
      } else {
        options.colorized = true;
        options.run_infragrammar(mode);
        return options.run_colorize();
      }
    });

    $("#preset_ndvi_red").click(function() {
      $('#modeSwitcher').val("infragrammar_mono").change();
      $('#m_exp').val("(B-R)/(B+R)");
      $('#preset-modal').modal('hide');
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        return glHandleOnSubmitInfraMono();
      } else {
        return options.run_infragrammar(mode);
      }
    });

    $("#preset_ndvi_red_color").click(function() {
      $('#modeSwitcher').val("infragrammar_mono").change();
      $('#m_exp').val("(B-R)/(B+R)");
      $('#preset-modal').modal('hide');
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        glHandleOnClickColor();
        return glHandleOnClickNdvi();
      } else {
        options.colorized = true;
        options.run_infragrammar(mode);
        return options.run_colorize();
      }
    });

    $("#btn-colorize").click(function() {
      if (webGlSupported) {
        glHandleOnClickColor();
        return glHandleOnClickNdvi();
      } else {
        options.colorized = true;
        options.run_infragrammar(mode);
        return run_colorize();
      }
    });

    $("#default_colormap").click(function() {
      var colormap;
      if (webglsupported) {
        glhandledefaultcolormap();
        glhandleonclickndvi();
      } else {
        options.colorized = true;
        colormap = colormap1;
        options.run_colorize();
      }
      return $("#btn-colorize").addClass("active");
    });

    $("#stretched_colormap").click(function() {
      var colormap;
      if (webGlSupported) {
        glHandleStretchedColormap();
        glHandleOnClickNdvi();
      } else {
        options.colorized = true;
        colormap = colormap2;
        options.run_colorize();
      }
      return $("#btn-colorize").addClass("active");
    });

    $("button#raw").click(function() {
      log.push("mode=raw");
      if (webGlSupported) {
        glHandleOnClickRaw();
      } else {
        jsHandleOnClickRaw();
      }
      return true;
    });

    $("button#ndvi").click(function() {
      log.push("mode=ndvi");
      if (webGlSupported) {
        glHandleOnClickNdvi();
      } else {
        jsHandleOnClickNdvi();
      }
      return true;
    });

    $("button#nir").click(function() {
      log.push("mode=nir");
      $("#m_exp").val("R");
      $("#modeSwitcher").val("infragrammar_mono").change();
      if (webGlSupported) {
        glHandleOnSubmitInfraMono();
      } else {
        jsHandleOnSubmitInfraMono();
      }
      return true;
    });
    $("#download").click(function() {
      downloadImage();
      return true;
    });

    $("#save").click(function() {
      var img, sendThumbnail;
      sendThumbnail = function() {
        var img;
        img = getCurrentImage();
        return FileUpload.uploadThumbnail(img, function() {
          $("#form-filename").val(FileUpload.getFilename());
          $("#form-log").val(JSON.stringify(log));
          return $("#save-form").submit();
        });
      };
      $("#save").prop("disabled", true);
      $("#save").html("Saving...");
      if (FileUpload.getFilename() === "") {
        img = getCurrentImage();
        FileUpload.fromBase64("camera", img, sendThumbnail);
      } else if (FileUpload.isLoadedFromFile() === false) {
        FileUpload.duplicate(sendThumbnail);
      } else {
        sendThumbnail();
      }
      return true;
    });

    $("#infragrammar_hsv").submit(function() {
      mode = "infragrammar_hsv";
      log_hsv();
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        glHandleOnSubmitInfraHsv();
      } else {
        options.run_infragrammar(mode);
      }
      return true;
    });

    $("#infragrammar").submit(function() {
      mode = "infragrammar";
      log_rgb();
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        glHandleOnSubmitInfra();
      } else {
        options.run_infragrammar(mode);
      }
      return true;
    });

    $("#infragrammar_mono").submit(function() {
      mode = "infragrammar_mono";
      log_mono();
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        glHandleOnSubmitInfraMono();
      } else {
        options.run_infragrammar(mode);
      }
      return true;
    });

    $("button#grey").click(function() {
      log.push("mode=ndvi");
      if (webGlSupported) {
        glHandleOnClickGrey();
      } else {
        jsHandleOnClickGrey();
      }
      return true;
    });

    $("button#colorify").click(function() {
      if (webGlSupported) {
        glHandleOnClickColorify();
      } else {
        jsHandleOnClickColorify();
      }
      return true;
    });

    $("button#color").click(function() {
      log.push("mode=ndvi&color=true");
      if (webGlSupported) {
        glHandleOnClickColor();
      } else {
        jsHandleOnClickColor();
      }
      return true;
    });

    $("#slider").slider().on("slide", function(event) {
      if (webGlSupported) {
        glHandleOnSlide(event);
      } else {
        jsHandleOnSlide(event);
      }
      return true;
    });

    $("#webgl-activate").click(function() {
      var href;
      href = window.location.href;
      if (webGlSupported) {
        href = href.replace(/(?:\?|&)webgl=true/gi, "");
      } else {
        href += href.indexOf("?") >= 0 ? "&webgl=true" : "?webgl=true";
      }
      window.location.href = href;
      return true;
    });

    $("#webcam-activate").click(function() {
      $("#save-modal-btn").show();
      $("#save-zone").show();
      camera.initialize();
      options.save_infragrammar_inputs();
      if (webGlSupported) {
        setInterval(function() {
          if (image && video_live) {
            options.run_infragrammar(mode);
            video_live = true;
          }
          camera.getSnapshot();
          if (options.colorized) {
            return options.run_colorize();
          }
        }, 33);
      } else {
        setInterval(function() {
          if (image && video_live) {
            options.run_infragrammar(mode);
            video_live = true;
          }
          camera.getSnapshot();
          if (options.colorized) {
            return run_colorize();
          }
        }, 250);
      }
      $('#preset-modal').modal('show');
      return true;
    });

    $("#snapshot").click(function() {
      camera.getSnapshot();
      return true;
    });

    $("#exit-fullscreen").click(function() {
      $("#image").css("display", "inline");
      $("#image").css("position", "relative");
      $("#image").css("height", "auto");
      $("#image").css("left", 0);
      $("#backdrop").hide();
      $("#exit-fullscreen").hide();
      $("#fullscreen").show();
      return true;
    });

    $("#fullscreen").click(function() {
      $("#image").css("display", "block");
      $("#image").css("height", "100%");
      $("#image").css("width", "auto");
      $("#image").css("position", "absolute");
      $("#image").css("top", "0px");
      $("#image").css("left", parseInt((window.innerWidth - $("#image").width()) / 2) + "px");
      $("#image").css("z-index", "2");
      $("#backdrop").show();
      $("#exit-fullscreen").show();
      $("#fullscreen").hide();
      return true;
    });

    $("#modeSwitcher").change(function() {
      $("#infragrammar, #infragrammar_mono, #infragrammar_hsv").hide();
      $("#" + $("#modeSwitcher").val()).css("display", "inline");
      return true;
    });

    $("[rel=tooltip]").tooltip()
    $("[rel=popover]").popover()
    return true;
  });
}

},{"./file-upload":4,"urlhash":1}],6:[function(require,module,exports){
// Generated by CoffeeScript 2.1.0
// This file was adapted from infragram-js:
// http://github.com/p-v-o-s/infragram-js.

module.exports = function javascriptProcessor() {

  var JsImage,
      b_exp = "",
      colormap,
      colormap1,
      colormap2,
      g_exp = "",
      get_channels,
      greyscale_colormap,
      histogram,
      hsv2rgb,
      image = null,
      infragrammar,
      infragrammar_mono,
      jsHandleOnClickGrey,
      jsHandleOnClickNdvi,
      jsHandleOnClickRaw,
      jsHandleOnSlide,
      jsHandleOnSubmitInfra,
      jsHandleOnSubmitInfraHsv,
      jsHandleOnSubmitInfraMono,
      m_exp = "",
      mode = "raw",
      ndvi,
      r_exp = "",
      render,
      rgb2hsv,
      segmented_colormap,
      set_mode,
      update,
      update_colorbar;

  JsImage = class JsImage {
    constructor(data1, width1, height1, channels) {
      this.data = data1;
      this.width = width1;
      this.height = height1;
      this.channels = channels;
    }

    copyToImageData(imgData) {
      return imgData.data.set(this.data);
    }

    extrema() {
      var c, i, j, l, m, maxs, mins, n, ref, ref1;
      n = this.width * this.height;
      mins = (function() {
        var l, ref, results;
        results = [];
        for (i = l = 0, ref = this.channels; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          results.push(this.data[i]);
        }
        return results;
      }).call(this);
      maxs = (function() {
        var l, ref, results;
        results = [];
        for (i = l = 0, ref = this.channels; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
          results.push(this.data[i]);
        }
        return results;
      }).call(this);
      j = 0;
      for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        for (c = m = 0, ref1 = this.channels; 0 <= ref1 ? m < ref1 : m > ref1; c = 0 <= ref1 ? ++m : --m) {
          if (this.data[j] > maxs[c]) {
            maxs[c] = this.data[j];
          }
          if (this.data[j] < mins[c]) {
            mins[c] = this.data[j];
          }
          j++;
        }
      }
      return [mins, maxs];
    }

  };

  histogram = function(array, [min, max], nbins) {
    var a, bins, d, i, l, len;
    bins = (function() {
      var l, ref, results;
      results = [];
      for (i = l = 0, ref = nbins; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results.push(0);
      }
      return results;
    })();
    d = (max - min) / nbins;
    for (l = 0, len = array.length; l < len; l++) {
      a = array[l];
      i = Math.floor((a - min) / d);
      if ((0 <= i && i < nbins)) {
        bins[i]++;
      }
    }
    return bins;
  };

  segmented_colormap = function(segments) {
    return function(x) {
      var i, l, len, m, ref, result, x0, x1, xstart, y0, y1;
      [y0, y1] = [0, 0];
      [x0, x1] = [segments[0][0], 1];
      if (x < x0) {
        return y0;
      }
      for (i = l = 0, len = segments.length; l < len; i = ++l) {
        [xstart, y0, y1] = segments[i];
        x0 = xstart;
        if (i === segments.length - 1) {
          x1 = 1;
          break;
        }
        x1 = segments[i + 1][0];
        if ((xstart <= x && x < x1)) {
          break;
        }
      }
      result = [];
      for (i = m = 0, ref = y0.length; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
        result[i] = (x - x0) / (x1 - x0) * (y1[i] - y0[i]) + y0[i];
      }
      return result;
    };
  };

  get_channels = function(img) {
    var b, g, i, l, mkImage, n, r, ref;
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0];
      g[i] = img.data[4 * i + 1];
      b[i] = img.data[4 * i + 2];
    }
    mkImage = function(d) {
      return new JsImage(d, img.width, img.height, 1);
    };
    return [mkImage(r), mkImage(g), mkImage(b)];
  };

  ndvi = function(nir, vis) {
    var d, i, l, n, ref;
    n = nir.width * nir.height;
    d = new Float64Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      d[i] = (nir.data[i] - vis.data[i]) / (nir.data[i] + vis.data[i]);
    }
    return new JsImage(d, nir.width, nir.height, 1);
  };

  function colorify(img, colormap) {
    var b, cimg, data, g, i, j, l, n, r, ref;
    $('#btn-colorize').addClass('active');
    n = img.width * img.height;
    data = new Uint8ClampedArray(4 * n);
    j = 0;
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      [r, g, b] = colormap(img.data[i]);
      data[j++] = r;
      data[j++] = g;
      data[j++] = b;
      data[j++] = 255;
    }
    cimg = new JsImage();
    cimg.width = img.width;
    cimg.height = img.height;
    cimg.data = data;
    return new JsImage(data, img.width, img.height, 4);
  };

  function infragrammar(img) {
    var b, g, i, l, n, o, r, ref;
    $('#btn-colorize').removeClass('active');
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    o = new Float32Array(4 * n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0] / 255;
      g[i] = img.data[4 * i + 1] / 255;
      b[i] = img.data[4 * i + 2] / 255;
      o[4 * i + 0] = 255 * r_exp(r[i], g[i], b[i]);
      o[4 * i + 1] = 255 * g_exp(r[i], g[i], b[i]);
      o[4 * i + 2] = 255 * b_exp(r[i], g[i], b[i]);
      o[4 * i + 3] = 255;
    }
    return new JsImage(o, img.width, img.height, 4);
  };

  function infragrammar_mono(img) {
    var b, g, i, l, n, o, r, ref;
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    o = new Float32Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0] / 255.0;
      g[i] = img.data[4 * i + 1] / 255.0;
      b[i] = img.data[4 * i + 2] / 255.0;
      o[i] = r_exp(r[i], g[i], b[i]);
    }
    return new JsImage(o, img.width, img.height, 1);
  };

  function render(img) {
    var ctx, d, e;
    e = $("#image")[0];
    e.width = img.width;
    e.height = img.height;
    ctx = e.getContext("2d");
    d = ctx.getImageData(0, 0, img.width, img.height);
    img.copyToImageData(d);
    return ctx.putImageData(d, 0, 0);
  };

  greyscale_colormap = segmented_colormap([[0, [0, 0, 0], [255, 255, 255]], [1, [255, 255, 255], [255, 255, 255]]]);

  colormap1 = segmented_colormap([[0, [0, 0, 255], [38, 195, 195]], [0.5, [0, 150, 0], [255, 255, 0]], [0.75, [255, 255, 0], [255, 50, 50]]]);

  colormap2 = segmented_colormap([[0, [0, 0, 255], [0, 0, 255]], [0.1, [0, 0, 255], [38, 195, 195]], [0.5, [0, 150, 0], [255, 255, 0]], [0.7, [255, 255, 0], [255, 50, 50]], [0.9, [255, 50, 50], [255, 50, 50]]]);

  colormap = colormap1;

  update_colorbar = (min, max) => {
    var b, ctx, d, e, g, i, j, k, l, m, r, ref, ref1;
    $('#colorbar-container')[0].style.display = 'inline-block';
    e = $('#colorbar')[0];
    ctx = e.getContext("2d");
    d = ctx.getImageData(0, 0, e.width, e.height);
    for (i = l = 0, ref = e.width; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      for (j = m = 0, ref1 = e.height; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
        [r, g, b] = colormap(i / e.width);
        k = 4 * (i + j * e.width);
        d.data[k + 0] = r;
        d.data[k + 1] = g;
        d.data[k + 2] = b;
        d.data[k + 3] = 255;
      }
    }
    ctx.putImageData(d, 0, 0);
    $("#colorbar-min")[0].textContent = min.toFixed(2);
    return $("#colorbar-max")[0].textContent = max.toFixed(2);
  };

  update = function(img) {
    var b, g, max, min, ndvi_img, normalize, r, result;
    $('#colorbar-container')[0].style.display = 'none';
    if (mode === "ndvi") {
      [r, g, b] = get_channels(img);
      ndvi_img = ndvi(r, b);
      // this isn't correct for NDVI; we want values from -1 to 1:
      // [[min],[max]] = ndvi_img.extrema()
      min = -1;
      max = 1;
      normalize = function(x) {
        return (x - min) / (max - min);
      };
      result = colorify(ndvi_img, function(x) {
        return colormap(normalize(x));
      });
      update_colorbar(min, max);
    } else if (mode === "raw") {
      result = new JsImage(img.data, img.width, img.height, 4);
    } else if (mode === "nir") {
      [r, g, b] = get_channels(img);
      result = colorify(r, function(x) {
        return [x, x, x];
      });
    } else {
      result = infragrammar(img);
    }
    return render(result);
  };

  save_expressions = function(r, g, b) {
    r = r.replace(/X/g, $('#slider').val() / 100);
    g = g.replace(/X/g, $('#slider').val() / 100);
    b = b.replace(/X/g, $('#slider').val() / 100);
    if (r === "") {
      r = "R";
    }
    if (g === "") {
      g = "G";
    }
    if (b === "") {
      b = "B";
    }
    eval("r_exp = function(R,G,B){var r=R,g=G,b=B;return " + r + ";}");
    eval("g_exp = function(R,G,B){var r=R,g=G,b=B;return " + g + ";}");
    return eval("b_exp = function(R,G,B){var r=R,g=G,b=B;return " + b + ";}");
  };

  save_expressions_hsv = function(h, s, v) {
    h = h.replace(/X/g, $('#slider').val() / 100);
    s = s.replace(/X/g, $('#slider').val() / 100);
    v = v.replace(/X/g, $('#slider').val() / 100);
    if (h === "") {
      h = "H";
    }
    if (s === "") {
      s = "S";
    }
    if (v === "") {
      v = "V";
    }
    eval("r_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[0];}");
    eval("g_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[1];}");
    return eval("b_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[2];}");
  };

  // modified from:
  // http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  hsv2rgb = function(h, s, v) {
    var data, f, i, p, q, rgb, t;
    data = [];
    if (s === 0) {
      rgb = [v, v, v];
    } else {
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      data = [v * (1 - s), v * (1 - s * (h - i)), v * (1 - s * (1 - (h - i)))];
      switch (i) {
        case 0:
          rgb = [v, t, p];
          break;
        case 1:
          rgb = [q, v, p];
          break;
        case 2:
          rgb = [p, v, t];
          break;
        case 3:
          rgb = [p, q, v];
          break;
        case 4:
          rgb = [t, p, v];
          break;
        default:
          rgb = [v, p, q];
      }
    }
    return rgb;
  };

  rgb2hsv = function(r, g, b) {
    var d, h, max, min, s, v;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    h = s = v = max;
    d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return [h, s, v];
  };

  function set_mode(new_mode) {
    mode = new_mode;
    update(image);
    if (mode === "ndvi") {
      return $("#colormaps-group")[0].style.display = "inline-block";
    } else {
      if ($("#colormaps-group").size() > 0) {
        return $("#colormaps-group")[0].style.display = "none";
      }
    }
  };

  function updateImage(img) {
    var ctx, height, imgCanvas, width;
    imgCanvas = document.getElementById("image");
    ctx = imgCanvas.getContext("2d");
    width = img.videoWidth || img.width;
    height = img.videoHeight || img.height;
    ctx.drawImage(img, 0, 0, width, height, 0, 0, imgCanvas.width, imgCanvas.height);
    image = ctx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
    return set_mode(mode);
  };

  jsHandleOnClickRaw = function() {
    return set_mode("raw");
  };

  jsHandleOnClickNdvi = function() {
    return set_mode("ndvi");
  };

  function runInfragrammar(mode) {
    return set_mode(mode);
  };

  function getCurrentImage() {
    var ctx, e;
    e = $("#image")[0];
    ctx = e.getContext("2d");
    return ctx.canvas.toDataURL("image/jpeg");
  };

  jsHandleOnSubmitInfraHsv = function() {
    save_expressions_hsv($('#h_exp').val(), $('#s_exp').val(), $('#v_exp').val());
    return set_mode("infragrammar_hsv");
  };

  jsHandleOnSubmitInfra = function() {
    save_expressions($('#r_exp').val(), $('#g_exp').val(), $('#b_exp').val());
    return set_mode("infragrammar");
  };

  jsHandleOnSubmitInfraMono = function() {
    save_expressions($('#m_exp').val(), $('#m_exp').val(), $('#m_exp').val());
    return set_mode("infragrammar_mono");
  };

  jsHandleOnClickGrey = function() {
    colormap = greyscale_colormap;
    return update(image);
  };

  jsHandleOnSlide = function(event) {
    if (mode === "infragrammar") {
      save_expressions($('#r_exp').val(), $('#g_exp').val(), $('#b_exp').val());
    } else if (mode === "infragrammar_hsv") {
      save_expressions_hsv($('#h_exp').val(), $('#s_exp').val(), $('#v_exp').val());
    } else {
      save_expressions($('#m_exp').val(), $('#m_exp').val(), $('#m_exp').val());
    }
    return update(image);
  };

  return {
    colorify: colorify,
    getCurrentImage: getCurrentImage,
    runInfragrammar: runInfragrammar,
    save_expressions: save_expressions,
    save_expressions_hsv: save_expressions_hsv,
    updateImage: updateImage
  }

}

},{}],7:[function(require,module,exports){
// Generated by CoffeeScript 2.1.0
(function() {
  // This file is part of infragram-js.

  // infragram-js is free software: you can redistribute it and/or modify
  // it under the terms of the GNU General Public License as published by
  // the Free Software Foundation, either version 2 of the License, or
  // (at your option) any later version.

  // infragram-js is distributed in the hope that it will be useful,
  // but WITHOUT ANY WARRANTY; without even the implied warranty of
  // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  // GNU General Public License for more details.

  // You should have received a copy of the GNU General Public License
  // along with infragram-js.  If not, see <http://www.gnu.org/licenses/>.
  var createBuffer, createContext, createTexture, drawScene, generateShader, glGetCurrentImage, glHandleDefaultColormap, glHandleOnClickColor, glHandleOnClickGrey, glHandleOnClickNdvi, glHandleOnClickRaw, glHandleOnSlide, glHandleOnSubmitInfra, glHandleOnSubmitInfraHsv, glHandleOnSubmitInfraMono, glHandleStretchedColormap, glInitInfragram, glRestoreContext, glRunInfragrammar, glSaveExpression, glSetMode, glShaderLoaded, glUpdateImage, imgContext, mapContext, vertices, waitForShadersToLoad;

  vertices = [-1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0];

  vertices.itemSize = 2;

  waitForShadersToLoad = 0;

  imgContext = null;

  mapContext = null;

  createBuffer = function(ctx, data) {
    var buffer, gl;
    gl = ctx.gl;
    buffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
    buffer.itemSize = data.itemSize;
    return buffer;
  };

  createTexture = function(ctx, textureUnit) {
    var gl, texture;
    gl = ctx.gl;
    texture = gl.createTexture();
    gl.activeTexture(textureUnit);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, ctx.canvas.width, ctx.canvas.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    return texture;
  };

  createContext = function(mode, selColormap, colormap, slider, canvasName) {
    var ctx;
    ctx = new Object();
    ctx.mode = mode;
    ctx.expression = ["", "", ""];
    ctx.selColormap = selColormap;
    ctx.colormap = colormap;
    ctx.slider = slider;
    ctx.updateShader = true;
    ctx.canvas = document.getElementById(canvasName);
    ctx.canvas.addEventListener("webglcontextlost", (function(event) {
      return event.preventDefault();
    }), false);
    ctx.canvas.addEventListener("webglcontextrestored", glRestoreContext, false);
    ctx.gl = getWebGLContext(ctx.canvas);
    if (ctx.gl) {
      ctx.gl.getExtension("OES_texture_float");
      ctx.vertexBuffer = createBuffer(ctx, vertices);
      ctx.framebuffer = ctx.gl.createFramebuffer();
      ctx.imageTexture = createTexture(ctx, ctx.gl.TEXTURE0);
      return ctx;
    } else {
      return null;
    }
  };

  drawScene = function(ctx, returnImage) {
    var gl, pColormap, pHsvUniform, pNdviUniform, pSampler, pSelColormapUniform, pSliderUniform, pVertexPosition;
    if (!returnImage) {
      requestAnimFrame(function() {
        return drawScene(ctx, false);
      });
    }
    if (ctx.updateShader) {
      ctx.updateShader = false;
      generateShader(ctx);
    }
    gl = ctx.gl;
    gl.viewport(0, 0, ctx.canvas.width, ctx.canvas.height);
    gl.useProgram(ctx.shaderProgram);
    gl.bindBuffer(gl.ARRAY_BUFFER, ctx.vertexBuffer);
    pVertexPosition = gl.getAttribLocation(ctx.shaderProgram, "aVertexPosition");
    gl.enableVertexAttribArray(pVertexPosition);
    gl.vertexAttribPointer(pVertexPosition, ctx.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);
    pSampler = gl.getUniformLocation(ctx.shaderProgram, "uSampler");
    gl.uniform1i(pSampler, 0);
    pSliderUniform = gl.getUniformLocation(ctx.shaderProgram, "uSlider");
    gl.uniform1f(pSliderUniform, ctx.slider);
    pNdviUniform = gl.getUniformLocation(ctx.shaderProgram, "uNdvi");
    gl.uniform1i(pNdviUniform, (ctx.mode === "ndvi" || ctx.colormap ? 1 : 0));
    pSelColormapUniform = gl.getUniformLocation(ctx.shaderProgram, "uSelectColormap");
    gl.uniform1i(pSelColormapUniform, ctx.selColormap);
    pHsvUniform = gl.getUniformLocation(ctx.shaderProgram, "uHsv");
    gl.uniform1i(pHsvUniform, (ctx.mode === "hsv" ? 1 : 0));
    pColormap = gl.getUniformLocation(ctx.shaderProgram, "uColormap");
    gl.uniform1i(pColormap, (ctx.colormap ? 1 : 0));
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertices.length / vertices.itemSize);
    if (returnImage) {
      return ctx.canvas.toDataURL("image/jpeg");
    }
  };

  generateShader = function(ctx) {
    var b, code, g, r;
    [r, g, b] = ctx.expression;
    // Map HSV to shader variable names
    r = r.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
    g = g.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
    b = b.toLowerCase().replace(/h/g, "r").replace(/s/g, "g").replace(/v/g, "b");
    // Sanitize strings
    r = r.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
    g = g.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
    b = b.replace(/[^xrgb\/\-\+\*\(\)\.0-9]*/g, "");
    // Convert int to float
    r = r.replace(/([0-9])([^\.])?/g, "$1.0$2");
    g = g.replace(/([0-9])([^\.])?/g, "$1.0$2");
    b = b.replace(/([0-9])([^\.])?/g, "$1.0$2");
    if (ctx.mode === "ndvi") {
      if (r !== "") {
        r = "((" + r + ") + 1.0) / 2.0";
      }
      if (g !== "") {
        g = "((" + g + ") + 1.0) / 2.0";
      }
      if (b !== "") {
        b = "((" + b + ") + 1.0) / 2.0";
      }
    }
    if (r === "") {
      r = "r";
    }
    if (g === "") {
      g = "g";
    }
    if (b === "") {
      b = "b";
    }
    code = $("#shader-fs-template").html();
    code = code.replace(/@1@/g, r);
    code = code.replace(/@2@/g, g);
    code = code.replace(/@3@/g, b);
    $("#shader-fs").html(code);
    return ctx.shaderProgram = createProgramFromScripts(ctx.gl, ["shader-vs", "shader-fs"]);
  };

  glSetMode = function(ctx, newMode) {
    ctx.mode = newMode;
    ctx.updateShader = true;
    if (ctx.mode === "ndvi") {
      $("#colorbar-container")[0].style.display = "inline-block";
      return $("#colormaps-group")[0].style.display = "inline-block";
    } else {
      $("#colorbar-container")[0].style.display = "none";
      return $("#colormaps-group")[0].style.display = "none";
    }
  };

  glShaderLoaded = function() {
    waitForShadersToLoad -= 1;
    if (!waitForShadersToLoad) {
      drawScene(imgContext);
      return drawScene(mapContext);
    }
  };

  glInitInfragram = function() {
    imgContext = createContext("raw", 1, 0, 1.0, "image");
    mapContext = createContext("raw", 1, 1, 1.0, "colorbar");
    waitForShadersToLoad = 2;
    $("#shader-vs").load("/shader.vert", glShaderLoaded);
    $("#shader-fs-template").load("/shader.frag", glShaderLoaded);
    if (imgContext && mapContext) {
      return true;
    } else {
      return false;
    }
  };

  glRestoreContext = function() {
    var imageData;
    imageData = imgContext.imageData;
    imgContext = createContext(imgContext.mode, imgContext.selColormap, imgContext.colormap, imgContext.slider, "image");
    mapContext = createContext(mapContext.mode, mapContext.selColormap, mapContext.colormap, mapContext.slider, "colorbar");
    if (imgContext && mapContext) {
      return glUpdateImage(imageData);
    }
  };

  glUpdateImage = function(img) {
    var gl;
    gl = imgContext.gl;
    imgContext.imageData = img;
    gl.activeTexture(gl.TEXTURE0);
    return gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
  };

  glGetCurrentImage = function() {
    return drawScene(imgContext, true);
  };

  glHandleDefaultColormap = function() {
    return imgContext.selColormap = mapContext.selColormap = 0;
  };

  glHandleStretchedColormap = function() {
    return imgContext.selColormap = mapContext.selColormap = 2;
  };

  glSaveExpression = function(a, b, c) {
    return imgContext.expression = [a, b, c];
  };

  glRunInfragrammar = function(mode) {
    return glSetMode(imgContext, "ndvi");
  };

  glHandleOnClickRaw = function() {
    return glSetMode(imgContext, "raw");
  };

  glHandleOnClickNdvi = function() {
    return glSetMode(imgContext, "ndvi");
  };

  glHandleOnSubmitInfraHsv = function() {
    return glSetMode(imgContext, "hsv");
  };

  glHandleOnSubmitInfra = function() {
    return glSetMode(imgContext, "rgb");
  };

  glHandleOnSubmitInfraMono = function() {
    return glSetMode(imgContext, "mono");
  };

  glHandleOnClickGrey = function() {
    return imgContext.selColormap = mapContext.selColormap = 1;
  };

  glHandleOnClickColor = function() {
    return imgContext.selColormap = mapContext.selColormap = 0;
  };

  glHandleOnSlide = function(event) {
    return imgContext.slider = event.value / 100.0;
  };

}).call(this);

},{}]},{},[2]);
