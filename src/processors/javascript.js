// Generated by CoffeeScript 2.1.0
// This file was adapted from infragram-js:
// http://github.com/p-v-o-s/infragram-js.

module.exports = function javascriptProcessor() {

  var JsImage = require('../util/JsImage.js'),
      b_exp = "",
      colormap,
      colormap1,
      colormap2,
      g_exp = "",
      get_channels,
      greyscale_colormap,
      hsv2rgb,
      image = null,
      infragrammar,
      infragrammar_mono,
      jsHandleOnClickGrey,
      jsHandleOnClickNdvi,
      jsHandleOnClickRaw,
      jsHandleOnSlide,
      jsHandleOnSubmitInfra,
      jsHandleOnSubmitInfraHsv,
      jsHandleOnSubmitInfraMono,
      m_exp = "",
      mode = "raw",
      ndvi,
      r_exp = "",
      render,
      rgb2hsv,
      segmented_colormap,
      set_mode,
      update,
      update_colorbar;

  function histogram(array, [min, max], nbins) {
    var a, bins, d, i, l, len;
    bins = (function() {
      var l, ref, results;
      results = [];
      for (i = l = 0, ref = nbins; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        results.push(0);
      }
      return results;
    })();
    d = (max - min) / nbins;
    for (l = 0, len = array.length; l < len; l++) {
      a = array[l];
      i = Math.floor((a - min) / d);
      if ((0 <= i && i < nbins)) {
        bins[i]++;
      }
    }
    return bins;
  };

  segmented_colormap = function(segments) {
    return function(x) {
      var i, l, len, m, ref, result, x0, x1, xstart, y0, y1;
      [y0, y1] = [0, 0];
      [x0, x1] = [segments[0][0], 1];
      if (x < x0) {
        return y0;
      }
      for (i = l = 0, len = segments.length; l < len; i = ++l) {
        [xstart, y0, y1] = segments[i];
        x0 = xstart;
        if (i === segments.length - 1) {
          x1 = 1;
          break;
        }
        x1 = segments[i + 1][0];
        if ((xstart <= x && x < x1)) {
          break;
        }
      }
      result = [];
      for (i = m = 0, ref = y0.length; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
        result[i] = (x - x0) / (x1 - x0) * (y1[i] - y0[i]) + y0[i];
      }
      return result;
    };
  };

  get_channels = function(img) {
    var b, g, i, l, mkImage, n, r, ref;
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0];
      g[i] = img.data[4 * i + 1];
      b[i] = img.data[4 * i + 2];
    }
    mkImage = function(d) {
      return new JsImage(d, img.width, img.height, 1);
    };
    return [mkImage(r), mkImage(g), mkImage(b)];
  };

  ndvi = function(nir, vis) {
    var d, i, l, n, ref;
    n = nir.width * nir.height;
    d = new Float64Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      d[i] = (nir.data[i] - vis.data[i]) / (nir.data[i] + vis.data[i]);
    }
    return new JsImage(d, nir.width, nir.height, 1);
  };

  function colorify(img, colormap) {
    var b, cimg, data, g, i, j, l, n, r, ref;
    $('#btn-colorize').addClass('active');
    n = img.width * img.height;
    data = new Uint8ClampedArray(4 * n);
    j = 0;
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      [r, g, b] = colormap(img.data[i]);
      data[j++] = r;
      data[j++] = g;
      data[j++] = b;
      data[j++] = 255;
    }
    cimg = new JsImage();
    cimg.width = img.width;
    cimg.height = img.height;
    cimg.data = data;
    return new JsImage(data, img.width, img.height, 4);
  };

  function infragrammar(img) {
    var b, g, i, l, n, o, r, ref;
    $('#btn-colorize').removeClass('active');
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    o = new Float32Array(4 * n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0] / 255;
      g[i] = img.data[4 * i + 1] / 255;
      b[i] = img.data[4 * i + 2] / 255;
      o[4 * i + 0] = 255 * r_exp(r[i], g[i], b[i]);
      o[4 * i + 1] = 255 * g_exp(r[i], g[i], b[i]);
      o[4 * i + 2] = 255 * b_exp(r[i], g[i], b[i]);
      o[4 * i + 3] = 255;
    }
    return new JsImage(o, img.width, img.height, 4);
  };

  function infragrammar_mono(img) {
    var b, g, i, l, n, o, r, ref;
    n = img.width * img.height;
    r = new Float32Array(n);
    g = new Float32Array(n);
    b = new Float32Array(n);
    o = new Float32Array(n);
    for (i = l = 0, ref = n; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      r[i] = img.data[4 * i + 0] / 255.0;
      g[i] = img.data[4 * i + 1] / 255.0;
      b[i] = img.data[4 * i + 2] / 255.0;
      o[i] = r_exp(r[i], g[i], b[i]);
    }
    return new JsImage(o, img.width, img.height, 1);
  };

  function render(img) {
    var ctx, d, e;
    e = $("#image")[0];
    e.width = img.width;
    e.height = img.height;
    ctx = e.getContext("2d");
    d = ctx.getImageData(0, 0, img.width, img.height);
    img.copyToImageData(d);
    return ctx.putImageData(d, 0, 0);
  };

  greyscale_colormap = segmented_colormap([[0, [0, 0, 0], [255, 255, 255]], [1, [255, 255, 255], [255, 255, 255]]]);

  colormap1 = segmented_colormap([[0, [0, 0, 255], [38, 195, 195]], [0.5, [0, 150, 0], [255, 255, 0]], [0.75, [255, 255, 0], [255, 50, 50]]]);

  colormap2 = segmented_colormap([[0, [0, 0, 255], [0, 0, 255]], [0.1, [0, 0, 255], [38, 195, 195]], [0.5, [0, 150, 0], [255, 255, 0]], [0.7, [255, 255, 0], [255, 50, 50]], [0.9, [255, 50, 50], [255, 50, 50]]]);

  colormap = colormap1;

  update_colorbar = (min, max) => {
    var b, ctx, d, e, g, i, j, k, l, m, r, ref, ref1;
    $('#colorbar-container')[0].style.display = 'inline-block';
    e = $('#colorbar')[0];
    ctx = e.getContext("2d");
    d = ctx.getImageData(0, 0, e.width, e.height);
    for (i = l = 0, ref = e.width; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
      for (j = m = 0, ref1 = e.height; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
        [r, g, b] = colormap(i / e.width);
        k = 4 * (i + j * e.width);
        d.data[k + 0] = r;
        d.data[k + 1] = g;
        d.data[k + 2] = b;
        d.data[k + 3] = 255;
      }
    }
    ctx.putImageData(d, 0, 0);
    $("#colorbar-min")[0].textContent = min.toFixed(2);
    return $("#colorbar-max")[0].textContent = max.toFixed(2);
  };

  update = function(img) {
    var b, g, max, min, ndvi_img, normalize, r, result;
    $('#colorbar-container')[0].style.display = 'none';
    if (mode === "ndvi") {
      [r, g, b] = get_channels(img);
      ndvi_img = ndvi(r, b);
      // this isn't correct for NDVI; we want values from -1 to 1:
      // [[min],[max]] = ndvi_img.extrema()
      min = -1;
      max = 1;
      normalize = function(x) {
        return (x - min) / (max - min);
      };
      result = colorify(ndvi_img, function(x) {
        return colormap(normalize(x));
      });
      update_colorbar(min, max);
    } else if (mode === "raw") {
      result = new JsImage(img.data, img.width, img.height, 4);
    } else if (mode === "nir") {
      [r, g, b] = get_channels(img);
      result = colorify(r, function(x) {
        return [x, x, x];
      });
    } else {
      result = infragrammar(img);
    }
    return render(result);
  };

  save_expressions = function(r, g, b) {
    r = r.replace(/X/g, $('#slider').val() / 100);
    g = g.replace(/X/g, $('#slider').val() / 100);
    b = b.replace(/X/g, $('#slider').val() / 100);
    if (r === "") {
      r = "R";
    }
    if (g === "") {
      g = "G";
    }
    if (b === "") {
      b = "B";
    }
    eval("r_exp = function(R,G,B){var r=R,g=G,b=B;return " + r + ";}");
    eval("g_exp = function(R,G,B){var r=R,g=G,b=B;return " + g + ";}");
    return eval("b_exp = function(R,G,B){var r=R,g=G,b=B;return " + b + ";}");
  };

  save_expressions_hsv = function(h, s, v) {
    h = h.replace(/X/g, $('#slider').val() / 100);
    s = s.replace(/X/g, $('#slider').val() / 100);
    v = v.replace(/X/g, $('#slider').val() / 100);
    if (h === "") {
      h = "H";
    }
    if (s === "") {
      s = "S";
    }
    if (v === "") {
      v = "V";
    }
    eval("r_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[0];}");
    eval("g_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[1];}");
    return eval("b_exp = function(R,G,B){var h=H,s=S,v=V,hsv = rgb2hsv(R, G, B), H = hsv[0], S = hsv[1], V = hsv[2]; return hsv2rgb(" + h + "," + s + "," + v + ")[2];}");
  };

  // modified from:
  // http://axonflux.com/handy-rgb-to-hsl-and-rgb-to-hsv-color-model-c
  hsv2rgb = function(h, s, v) {
    var data, f, i, p, q, rgb, t;
    data = [];
    if (s === 0) {
      rgb = [v, v, v];
    } else {
      i = Math.floor(h * 6);
      f = h * 6 - i;
      p = v * (1 - s);
      q = v * (1 - f * s);
      t = v * (1 - (1 - f) * s);
      data = [v * (1 - s), v * (1 - s * (h - i)), v * (1 - s * (1 - (h - i)))];
      switch (i) {
        case 0:
          rgb = [v, t, p];
          break;
        case 1:
          rgb = [q, v, p];
          break;
        case 2:
          rgb = [p, v, t];
          break;
        case 3:
          rgb = [p, q, v];
          break;
        case 4:
          rgb = [t, p, v];
          break;
        default:
          rgb = [v, p, q];
      }
    }
    return rgb;
  };

  rgb2hsv = function(r, g, b) {
    var d, h, max, min, s, v;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    h = s = v = max;
    d = max - min;
    s = max === 0 ? 0 : d / max;
    if (max === min) {
      h = 0; // achromatic
    } else {
      switch (max) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
      }
      h /= 6;
    }
    return [h, s, v];
  };

  function set_mode(new_mode) {
    mode = new_mode;
    update(image);
    if (mode === "ndvi") {
      return $("#colormaps-group")[0].style.display = "inline-block";
    } else {
      if ($("#colormaps-group").size() > 0) {
        return $("#colormaps-group")[0].style.display = "none";
      }
    }
  };

  function updateImage(img) {
    var ctx, height, imgCanvas, width;
    imgCanvas = document.getElementById("image");
    ctx = imgCanvas.getContext("2d");
    width = img.videoWidth || img.width;
    height = img.videoHeight || img.height;
    ctx.drawImage(img, 0, 0, width, height, 0, 0, imgCanvas.width, imgCanvas.height);
    image = ctx.getImageData(0, 0, imgCanvas.width, imgCanvas.height);
    return set_mode(mode);
  };

  jsHandleOnClickRaw = function() {
    return set_mode("raw");
  };

  jsHandleOnClickNdvi = function() {
    return set_mode("ndvi");
  };

  function runInfragrammar(mode) {
    return set_mode(mode);
  };

  function getCurrentImage() {
    var ctx, e;
    e = $("#image")[0];
    ctx = e.getContext("2d");
    return ctx.canvas.toDataURL("image/jpeg");
  };

  jsHandleOnSubmitInfraHsv = function() {
    save_expressions_hsv($('#h_exp').val(), $('#s_exp').val(), $('#v_exp').val());
    return set_mode("infragrammar_hsv");
  };

  jsHandleOnSubmitInfra = function() {
    save_expressions($('#r_exp').val(), $('#g_exp').val(), $('#b_exp').val());
    return set_mode("infragrammar");
  };

  jsHandleOnSubmitInfraMono = function() {
    save_expressions($('#m_exp').val(), $('#m_exp').val(), $('#m_exp').val());
    return set_mode("infragrammar_mono");
  };

  jsHandleOnClickGrey = function() {
    colormap = greyscale_colormap;
    return update(image);
  };

  jsHandleOnSlide = function(event) {
    if (mode === "infragrammar") {
      save_expressions($('#r_exp').val(), $('#g_exp').val(), $('#b_exp').val());
    } else if (mode === "infragrammar_hsv") {
      save_expressions_hsv($('#h_exp').val(), $('#s_exp').val(), $('#v_exp').val());
    } else {
      save_expressions($('#m_exp').val(), $('#m_exp').val(), $('#m_exp').val());
    }
    return update(image);
  };

  return {
    colorify: colorify,
    getCurrentImage: getCurrentImage,
    runInfragrammar: runInfragrammar,
    save_expressions: save_expressions,
    save_expressions_hsv: save_expressions_hsv,
    updateImage: updateImage
  }

}
