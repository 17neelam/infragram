// Generated by CoffeeScript 2.1.0
// This file was adapted from infragram-js:
// http://github.com/p-v-o-s/infragram-js.

var colorized, downloadImage, fetch_image, getCurrentImage, log, log_hsv, log_mono, log_rgb, mode, run_colorize, run_infragrammar, save_infragrammar_expressions, save_infragrammar_inputs, save_log, updateImage, video_live, webGlSupported;

(function() {

  webGlSupported = false;

  colorized = false;

  video_live = false;

  log = []; // a record of previous commands run

  mode = "raw";

  updateImage = function(img) {
    if (webGlSupported) {
      return glUpdateImage(img);
    } else {
      return jsUpdateImage(img);
    }
  };

  getCurrentImage = function() {
    var img;
    img = null;
    if (webGlSupported) {
      img = glGetCurrentImage();
    } else {
      img = jsGetCurrentImage();
    }
    return img;
  };

  run_colorize = function() {
    if (webGlSupported) {

    } else {
      // this is not an extra stage, it seems, in the gl code
      render(jsColorify(infragrammar_mono(image), function(x) {
        return colormap((x + 1) / 2);
      }));
    }
    return true;
  };

  save_infragrammar_inputs = function() {
    mode = $('#modeSwitcher').val();
    return save_infragrammar_expressions({
      'r': $('#r_exp').val(),
      'g': $('#g_exp').val(),
      'b': $('#b_exp').val(),
      'm': $('#m_exp').val(),
      'h': $('#h_exp').val(),
      's': $('#s_exp').val(),
      'v': $('#v_exp').val()
    });
  };

  save_infragrammar_expressions = function(args) {
    if (mode === "infragrammar") {
      if (webGlSupported) {
        glSaveExpression(args['r'], args['g'], args['b']);
      } else {
        save_expressions(args['r'], args['g'], args['b']);
      }
    }
    if (mode === "infragrammar_mono") {
      if (webGlSupported) {
        glSaveExpression(args['m'], args['m'], args['m']);
      } else {
        save_expressions(args['m'], args['m'], args['m']);
      }
    }
    if (mode === "infragrammar_hsv") {
      if (webGlSupported) {
        return glSaveExpression(args['h'], args['s'], args['v']);
      } else {
        return save_expressions_hsv(args['h'], args['s'], args['v']);
      }
    }
  };

  // this should accept an object with parameters r,g,b,h,s,v,m and mode
  run_infragrammar = function(mode) {
    save_log();
    if (webGlSupported) {
      return glRunInfragrammar(mode);
    } else {
      colorized = false;
      return jsRunInfragrammar(mode);
    }
  };

  log_mono = function() {
    var logEntry;
    logEntry = "mode=infragrammar_mono";
    logEntry += $("#m_exp").val() ? "&m=" + $("#m_exp").val() : "";
    logEntry += colorized ? "&c=true" : ""; // no way to succinctly store the colormap... just offer range of colorizations at view-time?
    return log.push(logEntry);
  };

  log_hsv = function() {
    var logEntry;
    logEntry = "mode=infragrammar_hsv";
    logEntry += $("#h_exp").val() ? "&h=" + $("#h_exp").val() : "";
    logEntry += $("#s_exp").val() ? "&s=" + $("#s_exp").val() : "";
    logEntry += $("#v_exp").val() ? "&v=" + $("#v_exp").val() : "";
    return log.push(logEntry);
  };

  log_rgb = function() {
    var logEntry;
    logEntry = "mode=infragrammar";
    logEntry += $("#r_exp").val() ? "&r=" + $("#r_exp").val() : "";
    logEntry += $("#g_exp").val() ? "&g=" + $("#g_exp").val() : "";
    logEntry += $("#b_exp").val() ? "&b=" + $("#b_exp").val() : "";
    return log.push(logEntry);
  };

  save_log = function() {
    if (mode === "infragrammar_mono") {
      return log_mono();
    } else if (mode === "infragrammar_hsv") {
      return log_hsv();
    } else if (mode === "infragrammar") {
      return log_rgb();
    }
  };

  downloadImage = function() {
    var event, format, lnk;
    // create an "off-screen" anchor tag
    lnk = document.createElement("a");
    // the key here is to set the download attribute of the a tag
    lnk.href = getCurrentImage();
    if (lnk.href.match('image/jpeg')) {
      format = "jpg";
    } else {
      format = "png";
    }
    lnk.download = (new Date()).toISOString().replace(/:/g, "_") + "." + format;
    // create a "fake" click-event to trigger the download
    if (document.createEvent) {
      event = document.createEvent("MouseEvents");
      event.initMouseEvent("click", true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
      lnk.dispatchEvent(event);
    } else if (lnk.fireEvent) {
      lnk.fireEvent("onclick");
    }
    return true;
  };

  // from a local URL (remote may be against js security rules)
  fetch_image = function(src, mode) {
    var img;
    $("#save-modal-btn").show();
    $("#save-zone").show();
    img = new Image();
    img.onload = function() {
      var filename;
      filename = src.split('/');
      filename = filename[filename.length - 1];
      FileUpload.setFilename(filename);
      if (mode) {
        if (mode.substring(0, 5) === "infra") {
          $("#modeSwitcher").val(mode).change();
        } else {
          $("button#" + mode).button("toggle");
          $("button#" + mode).click(); // this should be via a direct call, not a click; the show.jade page should not require buttons!
        }
      }
      save_infragrammar_expressions(params);
      if (mode === "ndvi") {
        save_infragrammar_expressions({
          'm': '(R-B)/(R+B)'
        });
        mode = "infragrammar_mono";
      } else if (mode === "nir") {
        save_infragrammar_expressions({
          'm': 'R'
        });
        mode = "infragrammar_mono";
      } else if (mode === "raw") {
        save_infragrammar_expressions({
          'r': 'R',
          'g': 'G',
          'b': 'B'
        });
        mode = "infragrammar";
      }
      updateImage(this);
      if (params['color'] === "true" || params['c'] === "true") {
        colorized = true; // before run_infrag, so it gets logged
      }
      run_infragrammar(mode); // this sets colorized to false!
      if (params['color'] === "true" || params['c'] === "true") {
        colorized = true; // again, so it gets run 
      }
      if (colorized) {
        $("button#color").button("toggle");
        return run_colorize();
      }
    };
    return img.src = src;
  };

}).call(this);
